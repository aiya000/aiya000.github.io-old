<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>あいや☆ぱぶりっしゅぶろぐ！ - baseパッケージにある型レベルプログラミング探検の旅</title>
        <link rel="stylesheet" type="text/css" href="../css/bootstrap.min.css" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/highlight.css" />
        <!-- bootstrap requires jquery -->
        <script type="text/javascript" src="../js/jquery-3.1.1.min.js"></script>
        <script type="text/javascript" src="../js/bootstrap.min.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default">
            <div class="navbar-header">
                <a class="navbar-brand" href="../">あいや☆ぱぶりっしゅぶろぐ！</a>
            </div>
            <ul class="nav navbar-nav">
                <li><a href="../">Home</a></li>
                <li><a href="../about.html">About</a></li>
                <li><a href="../profile.html">Profile</a></li>
                <li><a href="../products.html">Products</a></li>
                <li><a href="../archive.html">Archive</a></li>
            </ul>
        </nav>

        <div id="content">
            <h4>baseパッケージにある型レベルプログラミング探検の旅</h4>
            <link rel="stylesheet" type="text/css" href="../css/post.css" />

<div class="info">
    Posted on 2017/12/03 <br />
    

    Tags:
    
        [<a href="../tags/Haskell.html">Haskell</a>]
    
        [<a href="../tags/AdventCalendar2017.html">AdventCalendar2017</a>]
    
        [<a href="../tags/AdventCalendar.html">AdventCalendar</a>]
    

    <ul class="bookmarkers">
        <li> <!-- See https://about.twitter.com/ja/resources/buttons -->
            <a href="https://twitter.com/share" class="twitter-share-button" data-via="public_ai000ya" data-size="small">Tweet</a>
            <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
        </li>

        <li> <!-- See http://b.hatena.ne.jp/guide/bbutton -->
            <a href="http://b.hatena.ne.jp/entry/aiya000.github.io/posts/2017-12-03-type-programming-in-base.html" class="hatena-bookmark-button" data-hatena-bookmark-title="baseパッケージにある型レベルプログラミング探検の旅 - あいや☆ぱぶりっしゅぶろぐ！" data-hatena-bookmark-layout="standard-balloon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a>
            <script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
        </li>

        <li> <!-- See https://developers.facebook.com/docs/plugins/like-button?locale=ja_JP#configurator -->
            <div class="fb-like" data-href="https://aiya000.github.io/posts/2017-12-03-type-programming-in-base.html" data-layout="button_count" data-action="like" data-size="small" data-show-faces="false" data-share="true"></div>
        </li>

        <li> <!-- See https://getpocket.com/publisher/button -->
            <a data-pocket-label="pocket" data-pocket-count="horizontal" class="pocket-btn" data-lang="ja"></a>
            <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
        </li>
    </ul>
</div>

<hr />

<p>　数学といえば定理証明。 コンピュータといえばHaskell。</p>
<p>ということでHaskellで定理証明（型レベルプログラミング）です！</p>
<p>　この記事は<a href="https://qiita.com/advent-calendar/2017/math-and-computer">数学とコンピュータ Advent Calendar 2017</a>の、 12月3日の記事です。</p>
<h1 id="index">Index</h1>
<ul>
<li><a href="#%E5%A7%8B%E3%81%BE%E3%82%8A">始まり</a></li>
<li><a href="#datatypebool">Data.Type.Bool</a></li>
<li><a href="#datatypeequality">Data.Type.Equality</a>
<ul>
<li><a href="#equality">(==)</a></li>
</ul></li>
<li><a href="#ghctypelits">GHC.TypeLits</a>
<ul>
<li><a href="#nat-and-operators">Nat, (+), (-), (*), (^)</a></li>
<li><a href="#symbol">Symbol</a></li>
<li><a href="#typeerror">TypeError</a></li>
<li><a href="#nat-greater-or-equal">(&lt;=)</a>
<ul>
<li><a href="#%E4%BD%99%E8%AB%87">余談</a></li>
</ul></li>
</ul></li>
<li><a href="#equality-constraint">番外編: (~)</a></li>
<li><a href="#%E7%B5%82%E3%82%8F%E3%82%8A">終わり</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E3%83%9A%E3%83%BC%E3%82%B8">参考ページ</a></li>
</ul>
<h1 id="始まり">始まり</h1>
<p>　多くのHaskellerは標準モジュールとしてbaseを利用していることかと思いますが、 baseパッケージにはいくつかの、型レベルプログラミングのためのモジュールが存在します。</p>
<ul>
<li><a href="https://www.stackage.org/lts-9.6/package/base-4.9.1.0">base - Stackage</a></li>
</ul>
<p>　面白そうなので、探検していきます。<br />
皆、定理証明が大好きだもんな！</p>
<h1 id="data.type.bool">Data.Type.Bool <a name="datatypebool"></a></h1>
<p>　ハロー型レベル！</p>
<ul>
<li><a href="https://www.stackage.org/haddock/lts-9.6/base-4.9.1.0/Data-Type-Bool.html">Data.Type.Bool - Stackage</a></li>
</ul>
<p>　皆さん割と型レベルifは書きたくなることが多いと思いますが、 実はbaseに定義されています。 使ってみましょう。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">import </span><span class="dt">Data.Type.Bool</span> (<span class="dt">If</span>, type (&amp;&amp;), type (||), <span class="dt">Not</span>)

<span class="kw">type</span> <span class="dt">X</span> <span class="fu">=</span> <span class="dt">If</span> (<span class="dt">Not</span> <span class="ch">'False &amp;&amp; '</span><span class="dt">False</span> <span class="fu">||</span> <span class="ch">'True)</span>
            <span class="dt">Int</span>
            <span class="dt">Char</span>

<span class="ot">x ::</span> <span class="dt">X</span>
x <span class="fu">=</span> <span class="dv">10</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> return ()</code></pre></div>
<ul>
<li><a href="https://www.stackage.org/haddock/lts-9.6/base-4.9.1.0/Data-Type-Bool.html">Data.Type.Bool - Stackage</a></li>
</ul>
<p>　これらは<strong>closed type family</strong>です。</p>
<p>以下のように「条件が正しいかに関わらずコンパイルが通るけど、 条件が正しいかによって変数<code>x</code>の型が変わる」 っていうものも作れます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">import </span><span class="dt">Data.Type.Bool</span> (<span class="dt">If</span>, type (&amp;&amp;), type (||), <span class="dt">Not</span>)
<span class="kw">import </span><span class="dt">Data.Functor.Const</span> (<span class="dt">Const</span>)

<span class="kw">type</span> <span class="dt">X</span> <span class="fu">=</span> <span class="dt">If</span> (<span class="dt">Not</span> <span class="ch">'False &amp;&amp; '</span><span class="dt">False</span> <span class="fu">||</span> <span class="ch">'True)</span>
            (<span class="dt">Const</span> <span class="dt">Integer</span> <span class="dt">Char</span>)
            <span class="dt">Int</span>

<span class="ot">x ::</span> <span class="dt">X</span>
x <span class="fu">=</span> <span class="dv">10</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> return ()</code></pre></div>
<p>　これは余談ですが、 <code>instance Num a =&gt; Const a b</code>により<code>10 :: Const Integer Char</code>などのような型付けが正しいというのを、 僕が知った時もびっくりしました。<br />
<code>Const</code>すげー。</p>
<h1 id="data.type.equality">Data.Type.Equality <a name="datatypeequality"></a></h1>
<h2 id="section">(==) <a name="equality"></a></h2>
<p>　この<code>type (==)</code>はカインド多相（<code>PolyKinds</code>）なので、 <code>*</code>カインドではない型も、以下に実装があれば比較ができます。</p>
<ul>
<li><a href="https://www.stackage.org/haddock/lts-9.6/base-4.9.1.0/Data-Type-Equality.html#t:-61--61-">Data.Type.Equality (==) - Stackage</a>
<ul>
<li>例えば以下の種に属する型は、標準的に比較できる</li>
<li><code>type (==) Bool a b</code></li>
<li><code>type (==) Ordering a b</code></li>
<li><code>type (==) * a b</code></li>
<li><code>type (==) Nat a b</code></li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">import </span><span class="dt">Data.Type.Equality</span> (type (==))

<span class="kw">type</span> <span class="dt">X</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="fu">==</span> <span class="dt">Char</span>
<span class="kw">type</span> <span class="dt">Y</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="fu">==</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="dt">Z</span> <span class="fu">=</span> <span class="dv">1</span> <span class="fu">==</span> <span class="dv">2</span>

<span class="kw">type</span> <span class="dt">A</span> <span class="fu">=</span> [<span class="dt">Int</span>, <span class="dt">Char</span>] <span class="fu">==</span> [<span class="dt">Int</span>, <span class="dt">Bool</span>]
<span class="kw">type</span> <span class="dt">B</span> <span class="fu">=</span> (<span class="dt">Int</span>, <span class="dt">Char</span>) <span class="fu">==</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> return ()</code></pre></div>
<p>ghci</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">X</span>
<span class="dt">X</span><span class="ot"> ::</span> <span class="dt">Bool</span>
<span class="fu">=</span> <span class="ch">'False</span>

<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Y</span>
<span class="dt">Y</span><span class="ot"> ::</span> <span class="dt">Bool</span>
<span class="fu">=</span> <span class="ch">'True</span>

<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Z</span>
<span class="dt">Z</span><span class="ot"> ::</span> <span class="dt">Bool</span>
<span class="fu">=</span> <span class="dt">Z</span>

<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">A</span>
<span class="dt">A</span><span class="ot"> ::</span> <span class="dt">Bool</span>
<span class="fu">=</span> <span class="ch">'False</span>

<span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">B</span>
<span class="dt">B</span><span class="ot"> ::</span> <span class="dt">Bool</span>
<span class="fu">=</span> <span class="ch">'False</span></code></pre></div>
<p>　<code>(==)</code>は<strong>open type family</strong>なので、自前の型の比較も定義できます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">import </span><span class="dt">Data.Type.Equality</span> (type (==))

<span class="kw">data</span> <span class="dt">Foo</span> <span class="fu">=</span> <span class="dt">Bar</span> <span class="fu">|</span> <span class="dt">Baz</span>

<span class="kw">type</span> family <span class="dt">EqFoo</span> (<span class="ot">a ::</span> <span class="dt">Foo</span>) (<span class="ot">b ::</span> <span class="dt">Foo</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span>
  <span class="ch">'Bar `EqFoo` '</span><span class="dt">Bar</span> <span class="fu">=</span> <span class="ch">'True</span>
  <span class="ch">'Baz `EqFoo` '</span><span class="dt">Baz</span> <span class="fu">=</span> <span class="ch">'True</span>
  a    <span class="ot">`EqFoo`</span> a    <span class="fu">=</span> <span class="ch">'False</span>

<span class="kw">type</span> <span class="kw">instance</span> (<span class="ot">a ::</span> <span class="dt">Foo</span>) <span class="fu">==</span> (<span class="ot">b ::</span> <span class="dt">Foo</span>) <span class="fu">=</span> <span class="dt">EqFoo</span> a b

<span class="kw">type</span> <span class="dt">X</span> <span class="fu">=</span> <span class="ch">'Bar == '</span><span class="dt">Bar</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> return ()</code></pre></div>
<ul>
<li><a href="https://www.stackage.org/haddock/lts-9.6/base-4.9.1.0/Data-Type-Equality.html">Data.Type.Equality - Stackage</a></li>
</ul>
<p>　あとは色々や色々など、まだまだあります。</p>
<h1 id="ghc.typelits">GHC.TypeLits <a name="ghctypelits"></a></h1>
<p>　これは最強です。<br />
単純な依存型ならばsingletons使わないでこれだけでもいける。</p>
<hr />
<p>baseではないので解説は省略しますが、singletonsはここにあります。</p>
<ul>
<li><a href="https://www.stackage.org/haddock/lts-9.12/singletons-2.2/Data-Singletons.html">Data.Singletons - Stackage</a></li>
</ul>
<hr />
<p>　GHC.TypeLitsは型レベル自然数（<code>Nat</code>カインドとその型）と型レベル文字列（<code>Symbol</code>カインドとその型）へのユーティリティを提供します。</p>
<ul>
<li><a href="https://www.stackage.org/haddock/lts-9.6/base-4.9.1.0/GHC-TypeLits.html">GHC.TypeLits - Stackage</a></li>
</ul>
<h2 id="nat--">Nat, (+), (-), (*), (^) <a name="nat-and-operators"></a></h2>
<p>　<code>Proxy :: Proxy (1 + 2)</code>という異常な式が書けます。 <code>(/)</code>はないです。 ユークリッドさんはいません！</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">import </span><span class="dt">Data.Proxy</span> (<span class="dt">Proxy</span>(..))
<span class="kw">import </span><span class="dt">GHC.TypeLits</span> (natVal)
<span class="kw">import </span><span class="dt">GHC.TypeLits</span> (type (+), type (-), type (*)) <span class="co">-- ユークリッド感がない</span>

<span class="co">-- natVal :: forall n proxy. KnownNat n =&gt; proxy n -&gt; Integer</span>

<span class="ot">x ::</span> <span class="dt">Integer</span>
x <span class="fu">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>))

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print x
<span class="co">-- {output}</span>
<span class="co">-- 3</span></code></pre></div>
<p>　自然数モノイドの法則を簡易的に確認とかできます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">import </span><span class="dt">Data.Proxy</span> (<span class="dt">Proxy</span>(..))
<span class="kw">import </span><span class="dt">Data.Type.Bool</span> (type (&amp;&amp;))
<span class="kw">import </span><span class="dt">Data.Type.Equality</span> (type (==))
<span class="kw">import </span><span class="dt">GHC.TypeLits</span> (type (+))

<span class="kw">type</span> <span class="dt">MonoidLaws</span> <span class="fu">=</span>  <span class="dv">0</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">==</span> <span class="dv">1</span> <span class="fu">&amp;&amp;</span> <span class="dv">1</span> <span class="fu">==</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">0</span>
               <span class="fu">&amp;&amp;</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) <span class="fu">+</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>)

<span class="ot">x ::</span> <span class="dt">MonoidLaws</span> <span class="fu">~</span> <span class="ch">'True =&gt; ()</span>
x <span class="fu">=</span> ()

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print x
<span class="co">-- {output}</span>
<span class="co">-- ()</span></code></pre></div>
<p><code>(~) :: k -&gt; k -&gt; Constraint</code>については、以下を参照。</p>
<ul>
<li><a href="#%E7%95%AA%E5%A4%96%E7%B7%A8-">番外編: (~)</a></li>
</ul>
<h2 id="symbol">Symbol</h2>
<p>　<code>Nat</code>と同じく、めちゃめちゃ応用性のあるやつ。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>

<span class="kw">import </span><span class="dt">Data.Proxy</span> (<span class="dt">Proxy</span>(..))
<span class="kw">import </span><span class="dt">GHC.TypeLits</span> (<span class="dt">Symbol</span>, symbolVal)

<span class="ot">x ::</span> <span class="dt">String</span>
x <span class="fu">=</span> symbolVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="st">&quot;sugar&quot;</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> putStrLn x
<span class="co">-- {output}</span>
<span class="co">-- sugar</span></code></pre></div>
<p>　servantとかが利用してます。</p>
<ul>
<li><a href="http://krdlab.hatenablog.com/entry/2014/12/31/170158">haskell-servant の利用例とちょっとだけ仕組みの調査 - KrdLab’s blog</a></li>
<li><a href="https://www.stackage.org/lts-9.14/package/servant-0.11">servant - Stackage</a></li>
</ul>
<h2 id="typeerror">TypeError</h2>
<p>　<code>Monad</code>ブレイカーの二つ名で知られている（いない）唯一無二の存在、<code>error</code>関数の型レベル版です。</p>
<p>　<code>error</code>関数は型を無視して例外投げる破壊者ですが、<code>TypeError</code>は誤った証明をコンパイルエラーに上げるだけなので、 安全です。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">TypeError</span>
<span class="dt">TypeError</span><span class="ot"> ::</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> b
<span class="fu">=</span> (<span class="dt">TypeError</span> <span class="fu">...</span>)</code></pre></div>
<p>（<code>...</code>は多分 深淵を表していて、僕のような並のHaskellerではたどり着けない魔法がかかっている気がします）</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE PolyKinds #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span> (<span class="dt">TypeError</span>, <span class="dt">ErrorMessage</span>(..))

<span class="kw">type</span> family <span class="dt">Head</span> (<span class="ot">xs ::</span> [k])<span class="ot"> ::</span> k <span class="kw">where</span>
  <span class="dt">Head</span> <span class="ch">'[] = TypeError ('</span><span class="dt">Text</span> <span class="st">&quot;an empty list is given&quot;</span>)
  <span class="dt">Head</span> (x <span class="ch">': _) = x</span>

<span class="ot">x ::</span> <span class="dt">Head</span> <span class="ch">'[Int, Char, Bool]</span>
x <span class="fu">=</span> <span class="dv">10</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print x
<span class="co">-- {output}</span>
<span class="co">-- 10</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 以上省略 --</span>

<span class="ot">x ::</span> <span class="dt">Head</span> <span class="ch">'[] -- TypeError型の呼び出し</span>
x <span class="fu">=</span> <span class="dv">10</span> <span class="co">-- ここが15行目</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print x <span class="co">-- ここが18行目</span>
<span class="co">-- Test.hs:15:5: error:</span>
<span class="co">--     • an empty list is given</span>
<span class="co">--     • In the expression: 10</span>
<span class="co">--       In an equation for ‘x’: x = 10</span>
<span class="co">-- </span>
<span class="co">-- Test.hs:18:8: error:</span>
<span class="co">--     • an empty list is given</span>
<span class="co">--     • In the expression: print x</span>
<span class="co">--       In an equation for ‘main’: main = print x</span></code></pre></div>
<h2 id="section-1">(&lt;=) <a name="nat-greater-or-equal"></a></h2>
<p>　なぜかこれだけ<code>Constraint</code>です。 （<code>(&lt;=) :: (a :: Nat) -&gt; (a :: Nat) -&gt; Constraint</code>）</p>
<p>多分<code>Constraint</code>で等価性調べるなら<code>(~)</code>でいいし、 <code>&lt;</code>は本質的に<code>(n - 1) &lt;= m</code>だからそれでどうぞ、ってことだと思う。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span> (type (&lt;=))

<span class="ot">x ::</span> <span class="dv">2</span> <span class="fu">&lt;=</span> <span class="dv">2</span> <span class="ot">=&gt;</span> ()
x <span class="fu">=</span> ()

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print x
<span class="co">-- {output}</span>
<span class="co">-- ()</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 以上省略 --</span>

<span class="ot">x ::</span> <span class="dv">3</span> <span class="fu">&lt;=</span> <span class="dv">2</span> <span class="ot">=&gt;</span> ()
x <span class="fu">=</span> () <span class="co">-- </span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print x
<span class="co">-- Test.hs:11:14: error:</span>
<span class="co">--     • Couldn't match type ‘'False’ with ‘'True’</span>
<span class="co">--         arising from a use of ‘x’</span>
<span class="co">--     • In the first argument of ‘print’, namely ‘x’</span>
<span class="co">--       In the expression: print x</span>
<span class="co">--       In an equation for ‘main’: main = print x</span></code></pre></div>
<p>めっちゃ便利そう。</p>
<p><code>(&lt;=)</code>を<code>Constraint</code>から型レベルに下げた、<code>(&lt;=?)</code>というものあるみたいです。<br />
あとは</p>
<h3 id="余談">余談</h3>
<p>　これって<code>-Woverlapping-patterns</code>を警告されるだけで、コンパイルは通っちゃうんですね。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">import </span><span class="dt">GHC.TypeLits</span> (type (&lt;=))

<span class="ot">x ::</span> <span class="dv">3</span> <span class="fu">&lt;=</span> <span class="dv">2</span> <span class="ot">=&gt;</span> ()
x <span class="fu">=</span> ()

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> return ()
<span class="co">-- Test.hs:8:1: warning: [-Woverlapping-patterns]</span>
<span class="co">--     Pattern match is redundant</span>
<span class="co">--     In an equation for ‘x’: x = ...</span></code></pre></div>
<hr />
<p>　あとは</p>
<ul>
<li><code>CmpNat    (m :: Nat)    (n :: Nat)    :: Ordering</code></li>
<li><code>CmpSymbol (m :: Symbol) (n :: Symbol) :: Ordering</code></li>
</ul>
<p>とかあります。</p>
<ul>
<li><a href="https://www.stackage.org/haddock/lts-9.6/base-4.9.1.0/GHC-TypeLits.html">GHC.TypeLits</a></li>
</ul>
<h1 id="番外編">番外編: (~) <a name="equality-constraint"></a></h1>
<p>　<code>(~)</code>がどこから来てるのかわからないのでここに書いちゃいますが、 <code>(~)</code>はこういうのです。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>kind (<span class="fu">~</span>)
<span class="ot">(~) ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Constraint</span>

<span class="fu">&gt;&gt;&gt;</span><span class="ot"> () ::</span> <span class="dv">1</span> <span class="fu">~</span> <span class="dv">1</span> <span class="ot">=&gt;</span> ()
()

<span class="fu">&gt;&gt;&gt;</span><span class="ot"> () ::</span> <span class="dv">1</span> <span class="fu">~</span> <span class="dv">2</span> <span class="ot">=&gt;</span> ()

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">11</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span>
    • <span class="dt">Couldn't</span> match <span class="kw">type</span> ‘<span class="dv">1</span>’ with ‘<span class="dv">2</span>’
        arising from an expression <span class="kw">type</span> signature
    • <span class="dt">When</span> instantiating ‘it’, initially inferred to have
      this overly<span class="fu">-</span>general <span class="kw">type</span><span class="fu">:</span>
        <span class="dv">1</span> <span class="fu">~</span> <span class="dv">2</span> <span class="ot">=&gt;</span> ()
      <span class="dt">NB</span><span class="fu">:</span> <span class="dt">This</span> instantiation can be caused by the monomorphism restriction<span class="fu">.</span>

<span class="fu">&gt;&gt;&gt;</span><span class="ot"> () ::</span> <span class="dv">1</span> <span class="fu">~</span> <span class="ch">'True =&gt; ()</span>

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">12</span><span class="fu">:</span><span class="dv">11</span><span class="fu">:</span> error<span class="fu">:</span>
    • <span class="dt">Expected</span> kind ‘ghc<span class="fu">-</span>prim<span class="fu">-</span><span class="fl">0.5</span><span class="fu">.</span><span class="fl">0.0</span><span class="fu">:</span><span class="dt">GHC.Types.Nat</span>’,
        but ‘<span class="ch">'True’ has kind ‘Bool’</span>
    • <span class="dt">In</span> the second argument <span class="kw">of</span> ‘<span class="fu">~</span>’, namely ‘<span class="dt">True</span>’
      <span class="dt">In</span> an expression <span class="kw">type</span> signature<span class="fu">:</span> <span class="dv">1</span> <span class="fu">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> ()
      <span class="dt">In</span> the expression<span class="fu">:</span><span class="ot"> () ::</span> <span class="dv">1</span> <span class="fu">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> ()</code></pre></div>
<p>　<code>() :: () ~ () =&gt; ()</code>ってすごい面白い式じゃないですか？ 任意の式の中でも屈指の面白さだと思います。</p>
<h1 id="終わり">終わり</h1>
<p>　定理証明系Haskellや型レベルプログラミングとかいうと引く人が多いかもしれませんが、 実際問題「型レベルプログラミング実用的ではないのか？」というと、そんなことはないと思います。</p>
<p>例えばextensibleパッケージのここらへんが、いい感じに型レベルプログラミングを行っていると思います。 servantもかな？</p>
<ul>
<li><a href="https://www.stackage.org/haddock/lts-9.14/extensible-0.4.6/Data-Extensible-Internal.html">Data.Extensible.Internal - Stackage</a></li>
</ul>
<p>しかし「コンパイルエラーが難解になる」という問題が（程度によって）あるので、トレードオフです。<br />
そのパッケージの利便性がそのリスクを上回るのであれば、現実的だと思います。</p>
<h1 id="参考ページ">参考ページ</h1>
<ul>
<li><a href="https://github.com/lotz84/haskell/blob/master/docs/type-level-programming.md">haskell/type-level-programming.md at master - lotz84/haskell - GitHub</a></li>
<li><a href="http://krdlab.hatenablog.com/entry/2014/12/31/170158">haskell-servant の利用例とちょっとだけ仕組みの調査 - KrdLab’s blog</a></li>
</ul>

<hr />
<hr />

<p class="about-pr">
この記事はこちらから修正リクエストを送ることができます。 <br />
<a href="https://github.com/aiya000/aiya000.github.io/blob/src/posts/2017-12-03-type-programming-in-base.md">baseパッケージにある型レベルプログラミング探検の旅 - github</a> <br />
ゴミ箱ボタンの左にある、鉛筆ボタンを押してね！
</p>

<script src="../js/facebook-sdk-2.8.js"></script>

        </div>

        <div id="footer">
            (*^o^) { This blog powerd by Haskell <a href="http://jaspervdj.be/hakyll">Hakyll</a> <br />
            and Uses <a href="http://nkmr6194.github.io/Umi/">Umi</a>
        </div>
    </body>
</html>
